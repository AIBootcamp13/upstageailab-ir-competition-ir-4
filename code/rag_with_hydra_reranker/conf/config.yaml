# 모델 설정
model:
  name: "solar-pro2"  # solar-pro2, gemini-2.5-flash, gemini-2.5-flash-lite 등 사용 가능
  delay_seconds: 0  # Gemini rate limit 회피를 위한 각 호출 전 대기 시간 (초)
  retry_max: 5  # LLM 호출 재시도 최대 횟수
  retry_delay_seconds: 30  # 재시도 간 대기 시간(초)
  # name: "gemini-2.5-flash-lite"  # solar-pro2, gemini-2.5-flash, gemini-2.5-flash-lite 등 사용 가능
  # delay_seconds: 7  # Gemini rate limit 회피를 위한 각 호출 전 대기 시간 (초)
  temperature: 0
  seed: 1
  timeout: 1000
  reasoning_effort: "high"

# 평가 설정
eval:
  max_iterations: 0  # 0이면 제한 없음

# QA 설정
qa:
  use_final_answer: false  # false면 검색만, true면 검색 결과로 별도 QA 수행

# 프롬프트 설정
prompts:
  qa: |
    ## Role: 과학 상식 전문가

    ## Instructions
    - 사용자의 이전 메시지 정보 및 주어진 Reference 정보를 활용하여 간결하게 답변을 생성한다.
    - 주어진 검색 결과 정보로 대답할 수 없는 경우는 정보가 부족해서 답을 할 수 없다고 대답한다.
    - 한국어로 답변을 생성한다.
  
  function_calling: |
    ## Role: 과학 상식 전문가

    ## Instruction
    - 먼저 질문이 chit-chat 즉, 지극히 개인적질문이나 안부, 인사, 감정에 대한 질문 일 경우에는 절대로 search api를 호출하지 말고 적절한 대답을 생성한다.
    - chit-chat 즉, 지극히 개인적질문이나 안부, 인사, 감정에 대한 질문 이외에는 무조건 반드시 search api를 호출해야 하고 스스로 판단해서 대답하면 안된다.
    - 과학 상식 범위 내에서 설명 가능하더라도 반드시 search api를 호출해야 한다.
    - 추가 검색 없이도 과학 상식으로 설명 가능한 범위이더라도 반드시 search api를 호출해야 한다.
    - 어떤 사건에 관한것이거나 코드 프로그램적인 질문을 하더라도 반드시 search api를 호출해야 한다.
    - 평균을 구하는 코드 질문인경우 반드시 search api를 호출해야 한다.
    - search api를 호출할 때는 반드시 질문에 대한 최종 korean query를 생성해서 호출해야 한다.

  standalone_query_description: "Final korean query suitable for use in search from the user messages history."

  hyde: "다음 질문에 대해 전문적이고 사실과 정확한 정보를 바탕으로 핵심 정보가 포함된 요약 답변을 작성해줘."
  
# 리트리브 설정
retrieve:
  sparse:
    enabled: true   # sparse retrieve 활성화 여부
    top_k: 40       # sparse_retrieve에서 가져올 문서 수
  dense_upstage:
    enabled: true   # Upstage 임베딩 기반 dense 활성화 여부
    model_name: "solar-embedding-1-large"
    top_k: 40       # dense_retrieve_upstage에서 가져올 문서 수
    num_candidates: 500  # KNN 후보 수
  dense_sbert:
    enabled: false   # SBERT 임베딩 기반 dense 활성화 여부
    model_name: "snunlp/KR-SBERT-V40K-klueNLI-augSTS"
    top_k: 40       # dense_retrieve_sbert에서 가져올 문서 수
    num_candidates: 500  # KNN 후보 수
  dense_upstage_hyde:
    enabled: false  # HyDE 기법을 활용한 Upstage 임베딩 활성화 여부 (dense_upstage와 동일한 모델 사용)
    top_k: 40       # dense_retrieve_upstage_hyde에서 가져올 문서 수
    num_candidates: 500  # KNN 후보 수
  dense_gemini:
    enabled: false  # Gemini 임베딩 기반 dense 활성화 여부
    model_name: "models/gemini-embedding-001"  # Gemini 임베딩 모델 (3072차원)
    top_k: 40       # dense_retrieve_gemini에서 가져올 문서 수
    num_candidates: 500  # KNN 후보 수
    batch_size: 100  # 배치 처리 크기 (rate limit 회피)
    batch_delay_seconds: 65  # 배치 처리 후 대기 시간 (초)
  dense_gemini_hyde:
    enabled: false  # HyDE 기법을 활용한 Gemini 임베딩 활성화 여부
    top_k: 40       # dense_retrieve_gemini_hyde에서 가져올 문서 수
    num_candidates: 500  # KNN 후보 수
    batch_size: 100  # 배치 처리 크기 (rate limit 회피)
    batch_delay_seconds: 65  # 배치 처리 후 대기 시간 (초)

# 리랭커 설정
reranker:
  use_reranker: true
  use_hyde: false  # HyDE 기법으로 가상 문서 생성하여 리랭킹 여부
  model_name: "Qwen/Qwen3-Reranker-8B"
  batch_size: 4
  instruction: "Given a web search query, retrieve relevant passages"
  top_k: 3        # 리랭킹 후 최종 선택할 문서 수
  
# 임베딩 배치 설정 (모델명은 각 retrieve 섹션에 정의)
embedding:
  batch_size: 100

# 로깅 설정
logging:
  show_hyde_generated_document: true  # HyDE로 생성된 가상 문서 출력 여부
  show_retrieved_docids: true  # 각 리트리브 방식별 가져온 docid 리스트 출력 여부

# 인덱스 설정
index:
  name: "test"
  force_recreate: false  # false면 기존 인덱스 재사용, true면 삭제 후 재생성

# Elasticsearch 설정
elasticsearch:
  username: "elastic"
  hosts: ["https://localhost:9200"]
  # ca_certs: "/data/ephemeral/home/elasticsearch-8.8.0/config/certs/http_ca.crt"
  ca_certs: "/data/ephemeral/home/elasticsearch-9.0.3/config/certs/http_ca.crt"

# 파일 경로 설정
paths:
  documents: "../../input/data/documents.jsonl"
  eval_data: "../../input/data/eval.jsonl"
  output: "submission.csv"  # Hydra가 자동으로 outputs/{date}/{time}/ 폴더에 저장
